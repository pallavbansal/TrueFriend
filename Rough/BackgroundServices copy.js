// import BackgroundService from 'react-native-background-actions';
// import {getToken} from '../Utils/Streamapi';
// import Sound from 'react-native-sound';
// import socket from './Socket';
// import PushNotification from 'react-native-push-notification';
// let ringtone;
// const myuserid = 56;

// const connectToSocket = async () => {
//   socket.on('connect', () => {
//     console.log('Socket connection opened for background service');
//     socket.emit('register', myuserid);
//   });

//   socket.on('call', data => {
//     console.log('Received call in socket oncall in background :', data);
//     handleCall(data);
//   });

//   socket.on('error', error => {
//     console.error(error);
//   });

//   socket.on('disconnect', reason => {
//     console.log('Socket disconnected:', reason);
//   });
// };

// const handleCall = data => {
//   console.log('Received call in background :', data);
//   if (data.callaction === 'incoming') {
//     console.log('incoming :', data);
//     ringtone.setVolume(1);
//     ringtone.play();

//     PushNotification.localNotification({
//       /* Android Only Properties */
//       id: '12345', // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
//       autoCancel: true, // (optional) default: true
//       largeIcon: 'ic_launcher', // (optional) default: "ic_launcher"
//       smallIcon: 'ic_notification', // (optional) default: "ic_notification" with fallback for "ic_launcher"
//       bigText: `You have an incoming call from ${data.caller.name}`, // (optional) default: "message" prop
//       subText: 'Incoming Call', // (optional) default: none
//       color: 'red', // (optional) default: system default
//       vibrate: true, // (optional) default: true
//       vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
//       tag: 'incoming_call', // (optional) add tag to message
//       group: 'group', // (optional) add group to message
//       ongoing: false, // (optional) set whether this is an "ongoing" notification

//       /* iOS and Android properties */
//       title: 'Incoming Call', // (optional)
//       message: `You have an incoming call from ${data.caller.name}`, // (required)
//       playSound: false, // (optional) default: true
//       soundName: 'default', // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. Provide a string value if the sound is located in the android library. You can also provide a custom sound uri, using 'android.resource://' (Raw resources required). Example: 'android.resource://com.xyz/raw/sound.mp3'
//       actions: '["Accept", "Reject"]', // (Android only) See the doc for notification actions to know more
//     });

//     const timeoutId = setTimeout(() => handleReject(data), 15000);
//     return () => clearTimeout(timeoutId);
//   } else if (data.callaction === 'incoming-rejected') {
//     console.log('incoming-rejected :', data);
//   }
// };

// const handleCallAccept = async data => {
//   ringtone.stop();
//   socket.emit('call', {...data, callaction: 'accepted'});

//   try {
//     const token = await getToken();
//     const finalData = {
//       routeName: 'Call',
//       params: {
//         name: data?.reciever?.name.trim(),
//         token: token,
//         meetingId: data.meetingId,
//         micEnabled: true,
//         webcamEnabled: data.type === 'video' ? true : false,
//         isCreator: false,
//         mode: 'CONFERENCE',
//       },
//     };
//   } catch (error) {
//     console.error('Error navigating to call screen:', error);
//   }
// };

// const handleReject = data => {
//   ringtone.stop();
//   socket.emit('call', {...data, callaction: 'rejected'});
//   console.log('Call rejected');
// };

// const socketInBackground = async () => {
//   try {
//     ringtone = new Sound('incoming.mp3', Sound.MAIN_BUNDLE, error => {
//       if (error) {
//         console.log('failed to load the sound', error);
//         return;
//       }
//     });

//     await connectToSocket();

//     // Stop the socket connection when BackgroundService is stopped
//     await new Promise(resolve => {
//       BackgroundService.on('stop', () => {
//         if (socket) {
//           socket.disconnect();
//         }
//         ringtone.release();
//         resolve();
//       });
//     });

//     console.log('Background socket service stopped successfully! 1');
//   } catch (error) {
//     console.error('Error in socketInBackground:', error);
//   }
// };

// const startBackgroundSocketService = async () => {
//   console.log('in start background');
//   if (BackgroundService.isRunning()) {
//     console.log('Background socket service is already running');
//     return;
//   }

//   PushNotification.configure({
//     // (required) Called when a remote or local notification is opened or received
//     onNotification: function (notification) {
//       console.log('LOCAL NOTIFICATION ==>', notification);

//       if (notification.action === 'Accept') {
//         handleCallAccept(notification.data);
//       }
//     },
//     popInitialNotification: true,
//     requestPermissions: true,
//   });

//   const options = {
//     taskName: 'BackgroundSocketTask',
//     taskTitle: 'Wooing Chat Service',
//     taskDesc:
//       'Wooing Chat is running in the background to provide seamless chat experience.',
//     taskIcon: {
//       name: 'ic_launcher',
//       type: 'mipmap',
//     },
//     color: '#ff00ff',
//     parameters: {
//       delay: 1000, // Adjust the delay as needed
//     },
//     foregroundServiceType: 'dataSync',
//   };

//   try {
//     await BackgroundService.start(() => socketInBackground(), options);
//     console.log('Background socket service started successfully!');
//   } catch (e) {
//     console.error('Failed to start background socket service:', e);
//   }
// };

// const stopBackgroundSocketService = async () => {
//   try {
//     await BackgroundService.stop();
//     console.log('Background socket service stopped successfully! 2');
//   } catch (e) {
//     console.error('Failed to stop background socket service:', e);
//   }
// };

// export {startBackgroundSocketService, stopBackgroundSocketService};
